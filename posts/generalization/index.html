<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Theme Detection Script - Must be first to prevent FOUC -->
    <script>
        (function() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
        })();
    </script>
    
    <title>Generalization: An Epistemic Dichotomy - Rohola Zandie</title>
    <meta name="description" content="Exploring the fundamental tension in machine learning generalization between mean-seeking and mode-seeking behaviors through forward and reverse KL divergence.">

    <!-- SEO Meta Tags -->
    <meta name="keywords" content="machine learning, generalization, KL divergence, compression, manifold hypothesis, variational inference, epistemic uncertainty">
    <meta name="author" content="Rohola Zandie">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Generalization: An Epistemic Dichotomy">
    <meta property="og:description" content="Exploring the fundamental tension in machine learning generalization between mean-seeking and mode-seeking behaviors.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="../../assets/images/posts/generalization/forward-backward.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../assets/images/favicon.ico">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Geist+Mono:wght@100..900&display=swap" rel="stylesheet">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- MathJax for mathematical notation -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="../../assets/styles/portfolio.css">
    <link rel="stylesheet" href="../../assets/styles/blog.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../../index.html">
                <strong>Rohola Zandie</strong>
            </a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../../index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="../../blog.html">Blog</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../../persian-blog.html">بلاگ</a>
                    </li>
                    <li class="nav-item">
                        <button class="btn btn-link nav-link theme-toggle" id="themeToggle">
                            <i data-lucide="sun" class="icon-light"></i>
                            <i data-lucide="moon" class="icon-dark"></i>
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <!-- Back to Blog Link -->
            <a href="../../blog.html" class="back-to-blog">
                <i data-lucide="arrow-left"></i>
                Back to Blog
            </a>

            <!-- Post Header -->
            <header class="post-header">
                <h1 class="post-title">Generalization: An Epistemic Dichotomy</h1>
                <div class="post-meta">
                    <div class="post-meta-item">
                        <i data-lucide="calendar"></i>
                        <span>November 2025</span>
                    </div>
                    <div class="post-meta-item">
                        <i data-lucide="user"></i>
                        <span>Rohola Zandie</span>
                    </div>
                    <div class="post-meta-item">
                        <i data-lucide="clock"></i>
                        <span>8 min read</span>
                    </div>
                </div>
                <div class="blog-tags justify-content-center">
                    <span class="tag">Machine Learning</span>
                    <span class="tag">KL Divergence</span>
                    <span class="tag">Generalization</span>
                    <span class="tag">Philosophy</span>
                </div>
            </header>

            <!-- Post Content -->
            <article class="post-content">
                <h2>Introduction</h2>
                
                <p>In "generalization" the size of the parameter space should be smaller than the data space. This is exactly what compression means, and it's at the cornerstone of modern machine learning. But this premise inherently presupposes the <strong>manifold hypothesis</strong>—meaning the high dimensional data lies on a lower dimension and hence can be described by much smaller parameters. If the model is not expressive enough, reducing its uncertainty with respect to the data can be done in two different ways.</p>

                <p>In the first case, the model takes a more <em>inclusive</em> approach by "mean behavior", meaning it averages out the data instances that it observes! For example, if your model can't understand the multimodal data distribution, it takes the middle point, which is the average. The obvious problem here is that if those data samples are not very similar, the model seems to "confabulate" a middle state that doesn't even exist!</p>

                <p>On the other hand, the model can take a more <em>exclusive</em> approach by a "mode behavior", meaning it tries only to model the most frequent data point and ignore everything else! The problem with this case is that it simply misses the other data modalities that exist, just because they don't occur as much!</p>

                <p>This epistemic dichotomy in generalization arises when the model wants to stay simple. The issue stems from two ways to decrease the "distance" between the model $q_{\theta}$ and data distribution $p$.</p>

                <h2>Forward KL Divergence: Mean-Seeking Behavior</h2>

                <p>In the first case, we are looking to minimize the <strong>forward KL-divergence</strong>:</p>

                $$D_{\mathrm{KL}}(p \| q_\theta)=\mathbb{E}_{x \sim p}\left[\log \frac{p(x)}{q_\theta(x)}\right]=\sum_{x} p(x) \log\frac{p(x)}{q_\theta(x)}$$

                <p>Note that in this case, when $p(x) = 0$, the values of $q$ will be ignored because $p$ values are the weights in the formula. In other words if $p(x)$ is very small it has no consequence if $q_\theta$ is large! During the learning if $p$ is small $q_\theta$ will be ignored and hence will not be updated! This is why it's not a surprise if the model learns the mean value of multiple modalities while there might not be any data points corresponding to that! This is the <strong>mean-seeking</strong> behavior.</p>

                <p>Note that in this setting, whenever $p(x)=0$, the corresponding values of $q_\theta(x)$ are effectively ignored, because the weights in the objective come entirely from $p(x)$. In other words, if $p(x)$ is extremely small, it does not matter how large $q_\theta(x)$ becomes—the model receives essentially no gradient signal there. During training, regions where $p(x)$ is small contribute almost nothing, so $q_\theta(x)$ is neither penalized nor updated in those areas.</p>

                <p>This explains why the model may converge to a mean value across multiple modes, even when no actual data points lie near that region. This is the hallmark of <strong>mean-seeking behavior</strong>.</p>

                <h2>Reverse KL Divergence: Mode-Seeking Behavior</h2>

                <p>In the second regime, we are looking to minimize the <strong>backward KL-divergence</strong>:</p>

                $$D_{\mathrm{KL}}(q_\theta \| p)=\mathbb{E}_{x \sim q_\theta(x)}\left[\log \frac{q_\theta(x)}{p(x)}\right]=\sum_{x} q_\theta(x) \log\frac{q_\theta(x)}{p(x)}$$

                <p>Now we have the opposite problem: if the model decides to put zero probability $q_\theta(x) = 0$ where there is data $p(x) \neq 0$, then it will not be punished by the training algorithm! In this case it is better for the model to just fit to a portion of the data which appears more often and ignore the rest. This is the <strong>mode-seeking</strong> behavior.</p>

                <h2>Interactive Visualization</h2>

                <p>The interactive visualization below demonstrates the fundamental difference between forward and reverse KL divergence optimization. You can adjust the mode separation and animation speed to see how the approximating distributions behave differently.</p>

                <div class="kl-visualization" style="margin: 40px 0; padding: 40px; background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04)); border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(20px); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);">
                    <style>
                        .kl-visualization * {
                            box-sizing: border-box;
                        }

                        .kl-visualization {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                            color: var(--text-primary, #ffffff);
                        }

                        [data-theme="light"] .kl-visualization {
                            background: linear-gradient(145deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8)) !important;
                            border: 1px solid rgba(0, 0, 0, 0.1) !important;
                            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08) !important;
                        }

                        .kl-visualization h2.viz-title {
                            font-size: 2em;
                            margin-bottom: 10px;
                            background: linear-gradient(135deg, #a855f7, #3b82f6);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            background-clip: text;
                            text-align: center;
                        }

                        .kl-visualization .viz-subtitle {
                            font-size: 1em;
                            color: var(--text-muted, #94a3b8);
                            margin-bottom: 30px;
                            text-align: center;
                        }

                        .kl-visualization .viz-container {
                            width: 100%;
                            background: rgba(255, 255, 255, 0.03);
                            backdrop-filter: blur(10px);
                            border-radius: 16px;
                            padding: 25px;
                            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                            border: 1px solid rgba(255, 255, 255, 0.08);
                        }

                        [data-theme="light"] .kl-visualization .viz-container {
                            background: rgba(0, 0, 0, 0.02);
                            border: 1px solid rgba(0, 0, 0, 0.08);
                            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
                        }

                        .kl-visualization .viz-controls {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 20px;
                            margin-bottom: 30px;
                            justify-content: center;
                            align-items: center;
                        }

                        .kl-visualization .control-group {
                            display: flex;
                            flex-direction: column;
                            gap: 5px;
                        }

                        .kl-visualization label {
                            font-size: 0.85em;
                            color: var(--text-muted, #94a3b8);
                            text-transform: uppercase;
                            letter-spacing: 1px;
                            font-weight: 600;
                        }

                        .kl-visualization input[type="range"] {
                            width: 200px;
                            height: 6px;
                            background: rgba(255, 255, 255, 0.15);
                            outline: none;
                            border-radius: 3px;
                            -webkit-appearance: none;
                            appearance: none;
                        }

                        [data-theme="light"] .kl-visualization input[type="range"] {
                            background: rgba(0, 0, 0, 0.15);
                        }

                        .kl-visualization input[type="range"]::-webkit-slider-thumb {
                            -webkit-appearance: none;
                            appearance: none;
                            width: 18px;
                            height: 18px;
                            background: linear-gradient(135deg, #a855f7, #3b82f6);
                            border-radius: 50%;
                            cursor: pointer;
                            box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
                        }

                        .kl-visualization input[type="range"]::-moz-range-thumb {
                            width: 18px;
                            height: 18px;
                            background: linear-gradient(135deg, #a855f7, #3b82f6);
                            border-radius: 50%;
                            cursor: pointer;
                            border: none;
                            box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
                        }

                        .kl-visualization .value-display {
                            font-size: 0.85em;
                            color: #3b82f6;
                            font-weight: bold;
                        }

                        .kl-visualization button {
                            padding: 12px 30px;
                            background: linear-gradient(135deg, #a855f7, #3b82f6);
                            color: white;
                            border: none;
                            border-radius: 25px;
                            font-size: 0.95em;
                            font-weight: bold;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.3);
                        }

                        .kl-visualization button:hover {
                            transform: translateY(-2px);
                            box-shadow: 0 6px 30px rgba(168, 85, 247, 0.5);
                        }

                        .kl-visualization button:active {
                            transform: translateY(0);
                        }

                        .kl-visualization .canvas-container {
                            width: 100%;
                            display: flex;
                            justify-content: center;
                            margin-bottom: 20px;
                        }

                        .kl-visualization canvas {
                            border-radius: 12px;
                            background: rgba(0, 0, 0, 0.2);
                            max-width: 100%;
                            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
                        }

                        [data-theme="light"] .kl-visualization canvas {
                            background: rgba(255, 255, 255, 0.6);
                            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.08);
                        }

                        .kl-visualization .viz-legend {
                            display: flex;
                            justify-content: center;
                            gap: 25px;
                            margin-top: 20px;
                            flex-wrap: wrap;
                        }

                        .kl-visualization .legend-item {
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            font-size: 0.85em;
                            color: var(--text-secondary, #e2e8f0);
                        }

                        .kl-visualization .legend-line {
                            width: 30px;
                            height: 3px;
                            border-radius: 2px;
                        }

                        .kl-visualization .info-panel {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                            gap: 15px;
                            margin-top: 20px;
                            padding: 20px;
                            background: rgba(0, 0, 0, 0.15);
                            border-radius: 12px;
                            border: 1px solid rgba(255, 255, 255, 0.05);
                        }

                        [data-theme="light"] .kl-visualization .info-panel {
                            background: rgba(0, 0, 0, 0.03);
                            border: 1px solid rgba(0, 0, 0, 0.08);
                        }

                        .kl-visualization .info-item {
                            text-align: center;
                        }

                        .kl-visualization .info-label {
                            font-size: 0.8em;
                            color: var(--text-muted, #94a3b8);
                            margin-bottom: 5px;
                        }

                        .kl-visualization .info-value {
                            font-size: 1.1em;
                            font-weight: bold;
                            color: #3b82f6;
                        }

                        .kl-visualization .mode-toggle {
                            display: flex;
                            gap: 10px;
                            background: rgba(0, 0, 0, 0.2);
                            padding: 5px;
                            border-radius: 25px;
                            border: 1px solid rgba(255, 255, 255, 0.08);
                        }

                        [data-theme="light"] .kl-visualization .mode-toggle {
                            background: rgba(0, 0, 0, 0.05);
                            border: 1px solid rgba(0, 0, 0, 0.1);
                        }

                        .kl-visualization .mode-btn {
                            padding: 8px 20px;
                            background: transparent;
                            color: var(--text-muted, #94a3b8);
                            border: none;
                            border-radius: 20px;
                            font-size: 0.85em;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                            box-shadow: none;
                        }

                        .kl-visualization .mode-btn.active {
                            background: linear-gradient(135deg, #a855f7, #3b82f6);
                            color: white;
                            box-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);
                        }

                        .kl-visualization .mode-btn:hover {
                            transform: none;
                            box-shadow: none;
                            color: var(--text-primary, #ffffff);
                        }

                        .kl-visualization .mode-btn.active:hover {
                            box-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);
                        }
                    </style>

                    <h2 class="viz-title">KL Divergence Optimization</h2>
                    <div class="viz-subtitle">Visualizing Forward KL(p||q) vs Reverse KL(q||p) Minimization</div>
                    
                    <div class="viz-container">
                        <div class="viz-controls">
                            <div class="control-group">
                                <label>Mode Separation</label>
                                <input type="range" id="separation" min="0" max="15" step="0.1" value="5">
                                <span class="value-display" id="separationValue">5.0</span>
                            </div>
                            
                            <div class="control-group">
                                <label>Animation Speed</label>
                                <input type="range" id="speed" min="0.25" max="3" step="0.25" value="1">
                                <span class="value-display" id="speedValue">1.0x</span>
                            </div>
                            
                            <div class="mode-toggle">
                                <button class="mode-btn active" data-mode="both">Both KL</button>
                                <button class="mode-btn" data-mode="forward">Forward Only</button>
                                <button class="mode-btn" data-mode="reverse">Reverse Only</button>
                            </div>
                            
                            <button id="animateBtn">Start Animation</button>
                        </div>
                        
                        <div class="canvas-container">
                            <canvas id="klCanvas"></canvas>
                        </div>
                        
                        <div class="viz-legend">
                            <div class="legend-item">
                                <div class="legend-line" style="background: #00d4ff;"></div>
                                <span>Target p(x) - Bimodal</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line" style="background: #ff6b6b; border: 2px dashed #ff6b6b; background: none;"></div>
                                <span>Forward KL (Mean-Seeking)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-line" style="background: #7b68ee; border: 2px dotted #7b68ee; background: none;"></div>
                                <span>Reverse KL (Mode-Seeking)</span>
                            </div>
                        </div>
                        
                        <div class="info-panel">
                            <div class="info-item">
                                <div class="info-label">D<sub>KL</sub>(p || q<sub>θ</sub>)</div>
                                <div class="info-value" id="forwardKL">0.000</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">D<sub>KL</sub>(q<sub>θ</sub> || p)</div>
                                <div class="info-value" id="reverseKL">0.000</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Optimization Step</div>
                                <div class="info-value" id="step">0</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Convergence</div>
                                <div class="info-value" id="convergence">0%</div>
                            </div>
                        </div>
                    </div>
                </div>

                <script>
                    (function() {
                        const canvas = document.getElementById('klCanvas');
                        const ctx = canvas.getContext('2d');
                        
                        function resizeCanvas() {
                            canvas.width = Math.min(1000, canvas.parentElement.clientWidth);
                            canvas.height = 400;
                        }
                        resizeCanvas();
                        window.addEventListener('resize', resizeCanvas);
                        
                        let separation = 5;
                        let animationSpeed = 1;
                        let isAnimating = false;
                        let animationFrame = null;
                        let currentStep = 0;
                        let displayMode = 'both';
                        
                        let forwardQ = { mean: 2.5, std: 2 };
                        let reverseQ = { mean: 0, std: 1 };
                        let targetForwardQ = { mean: 2.5, std: 3 };
                        let targetReverseQ = { mean: 0, std: 1 };
                        
                        function gaussian(x, mean, std) {
                            const coefficient = 1 / (std * Math.sqrt(2 * Math.PI));
                            const exponent = -0.5 * Math.pow((x - mean) / std, 2);
                            return coefficient * Math.exp(exponent);
                        }
                        
                        function bimodalGaussian(x, separation) {
                            return 0.5 * gaussian(x, 0, 1) + 0.5 * gaussian(x, separation, 1);
                        }
                        
                        function computeKL(p, q, xs) {
                            let kl = 0;
                            const dx = xs[1] - xs[0];
                            for (let i = 0; i < xs.length; i++) {
                                const px = p(xs[i]);
                                const qx = q(xs[i]);
                                if (px > 1e-10 && qx > 1e-10) {
                                    kl += px * Math.log(px / qx) * dx;
                                }
                            }
                            return kl;
                        }
                        
                        function optimizeForwardKL(separation) {
                            const pMean = separation / 2;
                            const pVariance = 1 + (separation * separation) / 4;
                            const pStd = Math.sqrt(pVariance);
                            
                            const xs = [];
                            for (let x = -8; x <= separation + 8; x += 0.05) {
                                xs.push(x);
                            }
                            
                            const p = x => bimodalGaussian(x, separation);
                            const q = x => gaussian(x, pMean, pStd);
                            const kl = computeKL(p, q, xs);
                            
                            return { mean: pMean, std: pStd, kl: kl };
                        }
                        
                        function optimizeReverseKL(separation) {
                            const xs = [];
                            for (let x = -8; x <= separation + 8; x += 0.05) {
                                xs.push(x);
                            }
                            
                            let bestMean = 0;
                            let bestStd = 1;
                            let minKL = Infinity;
                            
                            for (let mean = -1; mean <= separation + 1; mean += 0.1) {
                                for (let std = 0.3; std <= 2; std += 0.1) {
                                    const p = x => bimodalGaussian(x, separation);
                                    const q = x => gaussian(x, mean, std);
                                    const kl = computeKL(q, p, xs);
                                    
                                    if (kl < minKL) {
                                        minKL = kl;
                                        bestMean = mean;
                                        bestStd = std;
                                    }
                                }
                            }
                            
                            if (separation > 3) {
                                for (let std = 0.5; std <= 1.5; std += 0.1) {
                                    const q = x => gaussian(x, 0, std);
                                    const p = x => bimodalGaussian(x, separation);
                                    const kl = computeKL(q, p, xs);
                                    
                                    if (kl < minKL) {
                                        minKL = kl;
                                        bestMean = 0;
                                        bestStd = std;
                                    }
                                }
                                
                                for (let std = 0.5; std <= 1.5; std += 0.1) {
                                    const q = x => gaussian(x, separation, std);
                                    const p = x => bimodalGaussian(x, separation);
                                    const kl = computeKL(q, p, xs);
                                    
                                    if (kl < minKL) {
                                        minKL = kl;
                                        bestMean = separation;
                                        bestStd = std;
                                    }
                                }
                            }
                            
                            return { mean: bestMean, std: bestStd, kl: minKL };
                        }
                        
                        function drawDistribution(distribution, color, style = 'solid') {
                            const width = canvas.width;
                            const height = canvas.height;
                            const padding = 40;
                            
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 3;
                            
                            if (style === 'dashed') {
                                ctx.setLineDash([10, 5]);
                            } else if (style === 'dotted') {
                                ctx.setLineDash([3, 3]);
                            } else {
                                ctx.setLineDash([]);
                            }
                            
                            ctx.beginPath();
                            
                            const xMin = -8;
                            const xMax = separation + 8;
                            const steps = 500;
                            
                            for (let i = 0; i <= steps; i++) {
                                const x = xMin + (xMax - xMin) * i / steps;
                                const y = distribution(x);
                                
                                const px = padding + (x - xMin) / (xMax - xMin) * (width - 2 * padding);
                                const py = height - padding - y * (height - 2 * padding) * 2;
                                
                                if (i === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                            
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        function drawAxes() {
                            const width = canvas.width;
                            const height = canvas.height;
                            const padding = 40;
                            
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.lineWidth = 1;
                            
                            ctx.beginPath();
                            ctx.moveTo(padding, height - padding);
                            ctx.lineTo(width - padding, height - padding);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(padding, padding);
                            ctx.lineTo(padding, height - padding);
                            ctx.stroke();
                        }
                        
                        function draw() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            drawAxes();
                            drawDistribution(x => bimodalGaussian(x, separation), '#00d4ff', 'solid');
                            
                            if (displayMode === 'both' || displayMode === 'forward') {
                                drawDistribution(x => gaussian(x, forwardQ.mean, forwardQ.std), '#ff6b6b', 'dashed');
                            }
                            
                            if (displayMode === 'both' || displayMode === 'reverse') {
                                drawDistribution(x => gaussian(x, reverseQ.mean, reverseQ.std), '#7b68ee', 'dotted');
                            }
                            
                            const xs = [];
                            for (let x = -8; x <= separation + 8; x += 0.1) {
                                xs.push(x);
                            }
                            
                            const p = x => bimodalGaussian(x, separation);
                            const qForward = x => gaussian(x, forwardQ.mean, forwardQ.std);
                            const qReverse = x => gaussian(x, reverseQ.mean, reverseQ.std);
                            
                            const forwardKLValue = computeKL(p, qForward, xs);
                            const reverseKLValue = computeKL(qReverse, p, xs);
                            
                            document.getElementById('forwardKL').textContent = forwardKLValue.toFixed(3);
                            document.getElementById('reverseKL').textContent = reverseKLValue.toFixed(3);
                        }
                        
                        function animate() {
                            if (!isAnimating) return;
                            
                            currentStep++;
                            const maxSteps = 600;
                            
                            if (currentStep <= maxSteps) {
                                const t = currentStep / maxSteps;
                                const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                                const lerpRate = 0.008 * animationSpeed * (0.3 + 0.7 * eased);
                                
                                forwardQ.mean = forwardQ.mean + (targetForwardQ.mean - forwardQ.mean) * lerpRate;
                                forwardQ.std = forwardQ.std + (targetForwardQ.std - forwardQ.std) * lerpRate;
                                reverseQ.mean = reverseQ.mean + (targetReverseQ.mean - reverseQ.mean) * lerpRate;
                                reverseQ.std = reverseQ.std + (targetReverseQ.std - reverseQ.std) * lerpRate;
                                
                                document.getElementById('step').textContent = currentStep;
                                document.getElementById('convergence').textContent = Math.round(t * 100) + '%';
                                
                                draw();
                                animationFrame = requestAnimationFrame(animate);
                            } else {
                                stopAnimation();
                            }
                        }
                        
                        function startAnimation() {
                            if (isAnimating) return;
                            isAnimating = true;
                            currentStep = 0;
                            
                            forwardQ = { mean: separation / 2, std: 1 };
                            reverseQ = { mean: separation / 2, std: 1 };
                            
                            const forwardOptimal = optimizeForwardKL(separation);
                            const reverseOptimal = optimizeReverseKL(separation);
                            
                            targetForwardQ = forwardOptimal;
                            targetReverseQ = reverseOptimal;
                            
                            document.getElementById('animateBtn').textContent = 'Stop Animation';
                            animate();
                        }
                        
                        function stopAnimation() {
                            isAnimating = false;
                            if (animationFrame) {
                                cancelAnimationFrame(animationFrame);
                            }
                            document.getElementById('animateBtn').textContent = 'Start Animation';
                        }
                        
                        document.getElementById('separation').addEventListener('input', (e) => {
                            separation = parseFloat(e.target.value);
                            document.getElementById('separationValue').textContent = separation.toFixed(1);
                            
                            const forwardOptimal = optimizeForwardKL(separation);
                            const reverseOptimal = optimizeReverseKL(separation);
                            
                            if (!isAnimating) {
                                forwardQ = forwardOptimal;
                                reverseQ = reverseOptimal;
                                targetForwardQ = forwardOptimal;
                                targetReverseQ = reverseOptimal;
                            }
                            
                            draw();
                        });
                        
                        document.getElementById('speed').addEventListener('input', (e) => {
                            animationSpeed = parseFloat(e.target.value);
                            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
                        });
                        
                        document.getElementById('animateBtn').addEventListener('click', () => {
                            if (isAnimating) {
                                stopAnimation();
                            } else {
                                startAnimation();
                            }
                        });
                        
                        document.querySelectorAll('.mode-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                                btn.classList.add('active');
                                displayMode = btn.dataset.mode;
                                draw();
                            });
                        });
                        
                        const forwardOptimal = optimizeForwardKL(separation);
                        const reverseOptimal = optimizeReverseKL(separation);
                        forwardQ = forwardOptimal;
                        reverseQ = reverseOptimal;
                        targetForwardQ = forwardOptimal;
                        targetReverseQ = reverseOptimal;
                        
                        draw();
                    })();
                </script>

                <p>In the visualization above, the target (data) distribution $p(x)$ (the cyan line) is a Gaussian mixture model with two components. The approximating distribution $q_\theta(x)$ is constrained to be a single Gaussian $\mathcal{N}(\mu, \sigma^2)$.</p>

                <p>Forward KL divergence $D_{KL}(p||q_\theta)$ minimization yields <strong>mean-seeking behavior</strong> (red dashed line), placing $q_\theta$ between the two modes to minimize the penalty where $p$ has mass but $q_\theta$ does not. Reverse KL divergence $D_{KL}(q_\theta||p)$ minimization exhibits <strong>mode-seeking behavior</strong> (blue dotted line), concentrating $q$ on a single mode to avoid placing mass where $p$ has low probability. This asymmetry has profound implications for variational inference and generative modeling.</p>

                <h2>The Philosophical Implications</h2>

                <p>This points out an uneasy fact about modeling: when we are trying to model the world we either have to make a "jump" by assigning non-zero probability to a situation that has not been observed unless we make the <strong>manifold assumption</strong> or we just have to ignore different data points in an attempt to explain (compress) everything by the most frequent observation. Note that there is a third way in which we can just memorize all the data points, and hence no compression and no generalization.</p>

                <p>This highlights a fundamental and uneasy truth about modeling: in order to represent the world, we must make a leap beyond what we have actually observed. Without some form of <strong>structural assumption</strong> (such as the manifold assumption in machine learning), we are forced to assign non-zero probability to situations that have never occurred in our data. This reflects a philosophical problem that goes back to <strong>Hume's problem of induction</strong>, namely that there is no purely logical way to justify predictions about unobserved cases based solely on past experience. Any such prediction requires an imaginative or assumptive step beyond the evidence.</p>

                <p>If, on the other hand, we avoid this leap and refuse to assign probability anywhere we have not seen data, we end up explaining everything solely by reference to the most frequent or typical observations, basically ignoring rarer data points, in an attempt to compress all knowledge into a single pattern.</p>

                <p>There is, of course, a third possibility: we could simply memorize every data point without attempting any form of generalization or compression. This "solution" ignores generalization entirely and with it, the ability to predict or understand new scenarios.</p>

                <h2>Conclusion</h2>

                <p>The dichotomy between mean-seeking and mode-seeking behaviors reveals a deep epistemic tension in machine learning and statistical inference. This is not merely a technical detail about optimization objectives—it reflects fundamental questions about how we can and should generalize from finite observations to make predictions about an uncertain world.</p>

                <p>The choice between forward and reverse KL divergence is ultimately a choice about what kinds of errors we are willing to tolerate: Do we prefer a model that covers all possibilities but may hallucinate impossible states (mean-seeking)? Or do we prefer a model that stays conservative, focusing only on high-probability regions while potentially missing important rare events (mode-seeking)?</p>

                <p>Neither approach is universally superior. The appropriate choice depends on the application, the cost of different types of errors, and our prior beliefs about the structure of the world. What remains constant is the inescapable truth that <strong>compression requires assumption</strong>, and all generalization involves a leap of faith beyond the data we have observed.</p>
            </article>

            <!-- Share Section -->
            <section class="post-share">
                <div class="row justify-content-center">
                    <div class="col-md-8">
                        <div class="share-content">
                            <h4>Share this article</h4>
                            <div class="share-buttons">
                                <a href="#" class="share-button" data-platform="twitter">
                                    <i data-lucide="twitter"></i> Twitter
                                </a>
                                <a href="#" class="share-button" data-platform="linkedin">
                                    <i data-lucide="linkedin"></i> LinkedIn
                                </a>
                                <a href="#" class="copy-link">
                                    <i data-lucide="link"></i> Copy Link
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="text-center">
                <p>&copy; 2025 Rohola Zandie. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Custom JavaScript -->
    <script src="../../assets/scripts/portfolio.js"></script>
    <script src="../../assets/scripts/blog.js"></script>
</body>
</html>
